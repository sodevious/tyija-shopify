'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var merge = require('lodash.merge');
var vue = require('vue');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var merge__default = /*#__PURE__*/_interopDefaultLegacy(merge);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spreadArray(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
}

var notNull = function (x) { return x !== null; };
var createElementFromStyle = function (block, serializers, children) {
    if (block.style) {
        var styleSerializer = serializers.styles[block.style];
        if (styleSerializer) {
            return vue.h(styleSerializer, {}, children);
        }
    }
    return children.flatMap(function (a) { return a; });
};
var blockIsSpan = function (block) {
    return block._type === 'span' && 'marks' in block && 'text' in block;
};
// @TODO This probably needs improving...
var serializerIsVueComponent = function (serializer) {
    return (typeof serializer === 'object' &&
        ('template' in serializer ||
            'setup' in serializer ||
            'render' in serializer ||
            'ssrRender' in serializer));
};
var findBlockSerializer = function (block, serializers) {
    if (block._type === 'list') {
        return serializers.list;
    }
    if ('listItem' in block) {
        return serializers.listItem;
    }
    if (blockIsSpan(block)) {
        return serializers.span;
    }
    return serializers.types[block._type];
};
// Typically returns an array of text nodes
// but might also include a VNode of a line break (<br>)
var renderText = function (text, serializers) {
    var lines = text.split('\n');
    for (var line = lines.length; line-- > 1;) {
        lines.splice(line, 0, serializers.hardBreak());
    }
    return lines;
};
var attachMarks = function (span, remainingMarks, serializers, markDefs) {
    var _a = __read(remainingMarks), mark = _a[0], marks = _a.slice(1);
    if (!mark) {
        return renderText(span.text, serializers);
    }
    var markDef = mark in serializers.marks
        ? { _type: mark, _key: '' }
        : markDefs.find(function (m) { return m._key === mark; });
    var serializer = markDef ? serializers.marks[markDef._type] : 'span';
    if (serializerIsVueComponent(serializer)) {
        var props = extractProps(markDef);
        return vue.h(serializer, props, function () {
            return attachMarks(span, marks, serializers, markDefs);
        });
    }
    if (typeof serializer === 'function') {
        return serializer(markDef || {}, attachMarks(span, marks, serializers, markDefs));
    }
    return vue.h(serializer, extractProps(markDef), attachMarks(span, marks, serializers, markDefs));
};
var spanSerializer = function (span, serializers, markDefs) {
    var defaults = ['em', 'strong', 'code'];
    // Defaults first
    var marks = __spreadArray([], __read(span.marks)).sort(function (a, b) {
        if (defaults.includes(a))
            return 1;
        if (defaults.includes(b))
            return -1;
        return 0;
    });
    return attachMarks(span, marks, serializers, markDefs);
};
var blockTextSerializer = function (block, serializers) {
    var nodes = block.children.flatMap(function (span) {
        return spanSerializer(span, serializers, block.markDefs);
    });
    return createElementFromStyle(block, serializers, nodes);
};
var underlineSerializer = function (_, children) {
    return vue.h('span', { style: 'text-decoration: underline;' }, children);
};
var linkSerializer = function (props, children) {
    return vue.h('a', { href: props.href, target: props.newtab ? '_blank' : undefined }, children);
};
var listSerializer = function (block, serializers) {
    var el = block.listItem === 'number' ? 'ol' : 'ul';
    return vue.h(el, {}, renderBlocks(block.children, serializers, block.level));
};
var listItemSerializer = function (block, serializers) {
    // Array of array of strings or nodes
    var children = renderBlocks(block.children, serializers, block.level);
    var shouldWrap = block.style && block.style !== 'normal';
    return vue.h('li', {}, shouldWrap ? createElementFromStyle(block, serializers, children) : children);
};
// Remove extraneous object properties
var extractProps = function (item) {
    if (item) {
        item._key; item._type; var props = __rest(item, ["_key", "_type"]);
        return props;
    }
    return {};
};
var serializeBlock = function (block, serializers) {
    // Find the serializer for this type of block
    var serializer = findBlockSerializer(block, serializers);
    // If none found, return null
    if (!serializer)
        return null;
    // If the serializer is a vue component, render it
    if (serializerIsVueComponent(serializer)) {
        var props = extractProps(block);
        return vue.h(serializer, props);
    }
    // Probably block text i.e. type 'block'
    // Could also be a span
    if (typeof serializer === 'function') {
        // We do some manual type assertion here
        // the findBlockSerializer method will have narrowed down the serializer if the block is a span type
        if (blockIsSpan(block)) {
            return serializer(block, serializers, []);
        }
        return serializer(block, serializers);
    }
    // Must be a string by this point
    return vue.h(serializer, {});
};
var createList = function (block) {
    return {
        _type: 'list',
        _key: block._key + "-parent",
        level: block.level,
        listItem: block.listItem,
        children: [block],
    };
};
var nestBlocks = function (blocks, level) {
    if (level === void 0) { level = 0; }
    var isListOrListItem = function (block) {
        return 'level' in block;
    };
    var hasChildren = function (block) { return block && 'children' in block; };
    var newBlocks = [];
    blocks.forEach(function (block) {
        if (!isListOrListItem(block)) {
            newBlocks.push(block);
            return;
        }
        var lastBlock = newBlocks[newBlocks.length - 1];
        if (block.level === level) {
            newBlocks.push(block);
            return;
        }
        if (block.level && block.level > level) {
            if (!hasChildren(lastBlock) ||
                !isListOrListItem(lastBlock) ||
                (lastBlock.level && lastBlock.level > block.level)) {
                newBlocks.push(createList(block));
            }
            else if (lastBlock.level === block.level &&
                lastBlock.listItem !== block.listItem) {
                newBlocks.push(createList(block));
            }
            else {
                lastBlock.children.push(block);
            }
        }
    });
    return newBlocks;
};
// Returns an array of strings, vnodes, or arrays of either
var renderBlocks = function (blocks, serializers, level) {
    if (level === void 0) { level = 0; }
    // Nest list items in lists
    var nestedBlocks = nestBlocks(blocks, level);
    // Loop through each block, and serialize it
    return nestedBlocks
        .map(function (block) { return serializeBlock(block, serializers); })
        .filter(notNull);
};
var defaultSerializers = {
    // For blocks
    types: {
        image: 'image',
        block: blockTextSerializer,
    },
    // For marks
    marks: {
        strong: 'strong',
        em: 'em',
        link: linkSerializer,
        underline: underlineSerializer,
    },
    // For span styles
    styles: {
        h1: 'h1',
        h2: 'h2',
        h3: 'h3',
        h4: 'h4',
        h5: 'h5',
        h6: 'h6',
        normal: 'p',
    },
    hardBreak: function () { return vue.h('br'); },
    span: spanSerializer,
    list: listSerializer,
    listItem: listItemSerializer,
};
var SanityBlocks = vue.defineComponent({
    functional: true,
    props: {
        blocks: {
            type: Array,
            default: function () { return []; },
        },
        serializers: {
            type: Object,
            default: function () { return ({}); },
        },
    },
    setup: function (props) {
        var serializers = merge__default['default']({}, defaultSerializers, props.serializers);
        return function () { return renderBlocks(props.blocks, serializers); };
    },
});

exports.SanityBlocks = SanityBlocks;
